module webgpu;

distinct Buffer = inline void*;

fn void Buffer.destroy(Buffer buffer) @extern("wgpuBufferDestroy");

// wgpuBufferGetConstMappedRange left out, since C3 has no void const *

fn BufferMapState Buffer.getMapState(Buffer buffer, usz offset, usz size) @extern("wgpuBufferGetMapState");

fn BufferMappedRange Buffer.getMappedRange(Buffer buffer) @extern("wgpuBufferGetMappedRange");

fn CULong Buffer.getSize(Buffer buffer) @extern("wgpuBufferGetSize");

fn BufferUsage Buffer.getUsage(Buffer buffer) @extern("wgpuBufferGetUsage");

fn BufferUsage Buffer.mapAsync(Buffer buffer, MapMode mode, usz offset, usz size,
    BufferMapAsyncCallback callback, UserData data) @extern("wgpuBufferMapAsync");

fn BufferUsage Buffer.setLabel(Buffer buffer, ZString label) @extern("wgpuBufferSetLabel");

fn BufferUsage Buffer.unmap(Buffer buffer) @extern("wgpuBufferUnmap");

fn BufferUsage Buffer.reference(Buffer buffer) @extern("wgpuBufferReference");

fn BufferUsage Buffer.release(Buffer buffer) @extern("wgpuBufferRelease");


def BufferMapAsyncCallback = fn void(BufferMapAsyncStatus status, UserData data);

def BufferUsageFlags = BufferUsage;

distinct BufferMappedRange = inline void*;

struct BufferBindingLayout {
    ChainedStruct* next;
    BufferBindingType type;
    Bool hasDynamicOffset;
    CULong minBindingSize;
}

struct BufferDescriptor {
    ChainedStruct* next;
    ZString label;
    BufferUsageFlags usage;
    CULong size;
    Bool mappedAtCreation;
}

struct ImageCopyBuffer {
    ChainedStruct* next;
    TextureDataLayout layout;
    Buffer buffer;
}

struct VertexBufferLayout {
    CULong arrayStride;
    VertexStepMode stepMode;
    usz attributeCount;
    VertexAttribute* attributes;
}

enum BufferMapState {
    UNMAPPED,
    PENDING,
    MAPPED
}

enum MapMode {
    NONE,
    READ,
    WRITE
}